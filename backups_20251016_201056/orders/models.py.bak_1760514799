from django.db import models
from django.contrib.auth import get_user_model
from decimal import Decimal

User = get_user_model()
class ServiceCategory(models.Model):
    name = models.CharField("Nom de la catégorie", max_length=120, unique=True)

    class Meta:
        verbose_name = "Catégorie de prestation"
        verbose_name_plural = "Catégories de prestation"
        ordering = ["name"]
        indexes = [models.Index(fields=["name"])]

    def __str__(self):
        return self.name

class LaundryItem(models.Model):
    UNIT_CHOICES = [
        ("ARTICLE", "Par article"),
        ("PAIRE", "Par paire"),
        ("METRE", "Au mètre"),
        ("KG", "Au kilo"),
    ]
    category = models.ForeignKey(
        ServiceCategory,
        verbose_name="Catégorie",
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="services",
    )
    name = models.CharField("Nom de la prestation", max_length=120)
    base_price_per_kg = models.DecimalField("Prix HT", max_digits=8, decimal_places=2, default=0)
    unit = models.CharField("Unité", max_length=10, choices=UNIT_CHOICES, default="ARTICLE")
    active = models.BooleanField("Actif", default=True)
class Meta:
        verbose_name = "Prestation"
        verbose_name_plural = "Prestations"
        ordering = ["name"]
        indexes = [models.Index(fields=["name"]), models.Index(fields=["active"])]
    def __str__(self):
        return self.name
class Order(models.Model):

    def update_totals(self):
        # Récupère les lignes
        items = self.orderitem_set.all()

        # Prix unitaire supposé sur i.item.price (adapter si ton champ porte un autre nom)
        def price_of(it):
            return getattr(getattr(it, 'item', None), 'price', 0) or 0

        total_ht = sum([(i.quantity or 0) * price_of(i) for i in items])
        total_weight = sum([(i.weight_kg_est or 0) for i in items])

        self.total_ht = total_ht
        self.total_weight_kg = total_weight
        # TVA en pourcentage sur Order.tva
        tva = (self.tva or 0) / 100
        self.total_ttc = total_ht * (1 + tva)
        try:
            self.save(update_fields=['total_ht','total_ttc','total_weight_kg'])
        except Exception:
            self.save()
class Meta:
        verbose_name = "Commande"
        verbose_name_plural = "Commandes"
        ordering = ["-created_at"]
        indexes = [
            models.Index(fields=["status"]),
            models.Index(fields=["created_at"]),
            models.Index(fields=["service_type"]),
        ]
    def __str__(self):
        return f"{self.code} - {self.customer}"

    def update_total(self):
        total = Decimal("0.00")
        for li in self.items.select_related("item").all():
            total += Decimal(str(li.line_total()))
        self.total_ht = total.quantize(Decimal("0.01"))
        tva_amount = (self.total_ht * self.tva_rate) / Decimal("100")
        self.total_ttc = (self.total_ht + tva_amount).quantize(Decimal("0.01"))
        self.save(update_fields=["total_ht", "total_ttc"])
class OrderItem(models.Model):
    order = models.ForeignKey(Order, verbose_name="Commande", on_delete=models.CASCADE, related_name="items")
    item = models.ForeignKey(LaundryItem, verbose_name="Prestation", on_delete=models.PROTECT)
    quantity = models.PositiveIntegerField("Quantité", default=1)
    weight_kg_est = models.DecimalField("Poids estimé (kg)", max_digits=6, decimal_places=2, null=True, blank=True)
    note = models.CharField("Note", max_length=240, blank=True, default="")
    photo = models.ImageField("Photo", upload_to="orders/%Y/%m/%d/", null=True, blank=True)
class Meta:
        verbose_name = "Ligne de commande"
        verbose_name_plural = "Lignes de commande"
    def __str__(self):
        return f"{self.item} x{self.quantity} ({self.order.code})"

    def line_total(self) -> float:
        # Prix de base
        price = float(self.item.base_price_per_kg or 0)
        # Calcul par unité
        if self.item.unit == "KG":
            kg = float(self.weight_kg_est or 0)
            return price * kg
        else:
            qty = float(self.quantity or 0)
            return price * qty

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)
        self.order.update_total()

    def delete(self, *args, **kwargs):
        super().delete(*args, **kwargs)
        self.order.update_total()